---
phase: 02-admin-couple-auth
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/app/(platform)/admin/layout.tsx
  - src/app/(platform)/admin/page.tsx
  - src/app/(platform)/admin/weddings/page.tsx
  - src/app/(platform)/admin/weddings/new/page.tsx
  - src/app/(platform)/admin/weddings/new/actions.ts
  - src/app/(auth)/login/page.tsx
  - src/app/(auth)/layout.tsx
  - prisma/seed.ts
  - package.json
autonomous: true

must_haves:
  truths:
    - "Admin can log in with email/password"
    - "Admin sees list of all wedding sites on platform"
    - "Admin can create new wedding site with couple account"
    - "Non-admin users are redirected away from /admin routes"
  artifacts:
    - path: "src/app/(platform)/admin/page.tsx"
      provides: "Admin dashboard with wedding count"
      min_lines: 20
    - path: "src/app/(platform)/admin/weddings/page.tsx"
      provides: "Wedding list table"
      contains: "findMany"
    - path: "src/app/(platform)/admin/weddings/new/page.tsx"
      provides: "Create wedding form"
      contains: "form"
    - path: "src/app/(auth)/login/page.tsx"
      provides: "Login form with server action"
      contains: "signIn"
    - path: "prisma/seed.ts"
      provides: "Admin user seeding"
      contains: "role.*admin"
  key_links:
    - from: "src/app/(platform)/admin/page.tsx"
      to: "src/lib/auth/auth.ts"
      via: "auth() call"
      pattern: "import.*auth.*from.*auth"
    - from: "src/app/(platform)/admin/weddings/new/actions.ts"
      to: "prisma"
      via: "$transaction"
      pattern: "prisma\\.\\$transaction"
---

<objective>
Build admin authentication and management dashboard

Purpose: Enable platform administrators to log in and manage all wedding sites. This includes viewing all weddings, creating new wedding sites, and assigning couple accounts. The admin dashboard bypasses tenant context to access all platform data.

Output: Working admin login flow, admin dashboard showing all weddings, and ability to create new wedding sites with associated couple accounts.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@wedding-platform/.planning/PROJECT.md
@wedding-platform/.planning/ROADMAP.md
@wedding-platform/.planning/STATE.md
@wedding-platform/.planning/phases/02-admin-couple-auth/02-RESEARCH.md

# From Plan 01 (will be available at execution time)
@wedding-platform/src/lib/auth/auth.ts
@wedding-platform/src/lib/auth/password.ts
@wedding-platform/prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create login page and auth layout</name>
  <files>
    - src/app/(auth)/layout.tsx
    - src/app/(auth)/login/page.tsx
  </files>
  <action>
Create src/app/(auth)/layout.tsx - minimal centered layout for auth pages:
```typescript
export default function AuthLayout({ children }: { children: React.ReactNode }) {
  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-50 px-4">
      <div className="w-full max-w-md">
        {children}
      </div>
    </div>
  )
}
```

Create src/app/(auth)/login/page.tsx with server action login:
- Import signIn from @/lib/auth/auth
- Import redirect from next/navigation
- Create server action `login(formData: FormData)`:
  1. Extract email and password from formData
  2. Call signIn("credentials", { email, password, redirect: false })
  3. If error, return (will handle error state in later phase)
  4. Check result, redirect to /dashboard or /admin based on role
- Form with email input (type="email", required), password input (type="password", required, minLength=8)
- Submit button "Sign In"
- Style with Tailwind: card with shadow, labels, inputs with border/rounded

NOTE: For the redirect after login, we need to fetch the session after successful signIn to check role. Use a two-step approach:
1. signIn with redirect: false
2. If no error, redirect to /dashboard (couple dashboard handles redirect to admin if needed)

Alternative cleaner approach: Use a client component with useRouter and signIn from next-auth/react for better UX. But for simplicity, use server action with redirect to /dashboard, and dashboard page checks role and redirects admin to /admin.
  </action>
  <verify>
- File src/app/(auth)/login/page.tsx exists with form and server action
- `npx tsc --noEmit` passes
- Form has accessible labels and inputs
  </verify>
  <done>Login page created with email/password form and server action that calls signIn</done>
</task>

<task type="auto">
  <name>Task 2: Create admin dashboard and wedding management pages</name>
  <files>
    - src/app/(platform)/layout.tsx
    - src/app/(platform)/admin/layout.tsx
    - src/app/(platform)/admin/page.tsx
    - src/app/(platform)/admin/weddings/page.tsx
    - src/app/(platform)/admin/weddings/new/page.tsx
    - src/app/(platform)/admin/weddings/new/actions.ts
  </files>
  <action>
Create src/app/(platform)/layout.tsx - shared authenticated layout:
```typescript
import { auth } from "@/lib/auth/auth"
import { redirect } from "next/navigation"

export default async function PlatformLayout({ children }: { children: React.ReactNode }) {
  const session = await auth()
  if (!session) {
    redirect("/login")
  }
  return <>{children}</>
}
```

Create src/app/(platform)/admin/layout.tsx - admin-specific layout with role check:
```typescript
import { auth } from "@/lib/auth/auth"
import { redirect } from "next/navigation"
import Link from "next/link"

export default async function AdminLayout({ children }: { children: React.ReactNode }) {
  const session = await auth()

  // Defense-in-depth: middleware checks, but verify here too (CVE-2025-29927)
  if (!session || session.user.role !== "admin") {
    redirect("/dashboard")
  }

  return (
    <div className="min-h-screen bg-gray-100">
      <nav className="bg-white shadow-sm">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="flex justify-between h-16 items-center">
            <div className="flex space-x-8">
              <Link href="/admin" className="font-semibold text-gray-900">Admin</Link>
              <Link href="/admin/weddings" className="text-gray-600 hover:text-gray-900">Weddings</Link>
            </div>
            <div className="text-sm text-gray-600">{session.user.email}</div>
          </div>
        </div>
      </nav>
      <main className="max-w-7xl mx-auto py-6 px-4 sm:px-6 lg:px-8">
        {children}
      </main>
    </div>
  )
}
```

Create src/app/(platform)/admin/page.tsx - admin dashboard:
- Import auth from @/lib/auth/auth
- Import prisma from @/lib/db/prisma (NOT within tenant context - admin sees all)
- Fetch wedding count: prisma.wedding.count()
- Fetch user count: prisma.user.count()
- Display stats cards: Total Weddings, Total Users
- Link to /admin/weddings

IMPORTANT: Admin operations do NOT use withTenantContext(). The Prisma extension only adds tenant filter when getTenantContext() returns a value. For admin operations, no tenant context is set, so queries return all data.

Create src/app/(platform)/admin/weddings/page.tsx - wedding list:
- Fetch all weddings with tenant: prisma.wedding.findMany({ include: { tenant: true }, orderBy: { createdAt: "desc" } })
- Display table with columns: Subdomain, Couple Names, Created, Actions
- Link to create new: /admin/weddings/new
- Each row links to edit (placeholder for now: /admin/weddings/[id])

Create src/app/(platform)/admin/weddings/new/page.tsx - create wedding form:
- Form with fields: subdomain, partner1Name, partner2Name, coupleEmail, couplePassword
- Import createWeddingSite action
- Subdomain validation hint: lowercase letters, numbers, hyphens only
- Password hint: minimum 8 characters

Create src/app/(platform)/admin/weddings/new/actions.ts - server action:
```typescript
"use server"

import { auth } from "@/lib/auth/auth"
import { prisma } from "@/lib/db/prisma"
import { hashPassword } from "@/lib/auth/password"
import { redirect } from "next/navigation"
import { z } from "zod"

const createWeddingSchema = z.object({
  subdomain: z.string().min(3).max(63).regex(/^[a-z0-9-]+$/, "Lowercase letters, numbers, and hyphens only"),
  partner1Name: z.string().min(1, "Partner 1 name is required"),
  partner2Name: z.string().min(1, "Partner 2 name is required"),
  coupleEmail: z.string().email("Valid email required"),
  couplePassword: z.string().min(8, "Password must be at least 8 characters"),
})

export async function createWeddingSite(formData: FormData) {
  const session = await auth()

  if (!session || session.user.role !== "admin") {
    throw new Error("Unauthorized")
  }

  const parsed = createWeddingSchema.safeParse({
    subdomain: formData.get("subdomain"),
    partner1Name: formData.get("partner1Name"),
    partner2Name: formData.get("partner2Name"),
    coupleEmail: formData.get("coupleEmail"),
    couplePassword: formData.get("couplePassword"),
  })

  if (!parsed.success) {
    // In production, would return error state. For now, throw.
    throw new Error(parsed.error.errors.map(e => e.message).join(", "))
  }

  const data = parsed.data

  // Create tenant, wedding, and user in transaction
  await prisma.$transaction(async (tx) => {
    const tenant = await tx.tenant.create({
      data: {
        subdomain: data.subdomain,
        name: `${data.partner1Name} & ${data.partner2Name}`,
      },
    })

    await tx.wedding.create({
      data: {
        tenantId: tenant.id,
        partner1Name: data.partner1Name,
        partner2Name: data.partner2Name,
      },
    })

    await tx.user.create({
      data: {
        email: data.coupleEmail,
        hashedPassword: await hashPassword(data.couplePassword),
        name: `${data.partner1Name} & ${data.partner2Name}`,
        role: "couple",
        tenantId: tenant.id,
      },
    })
  })

  redirect("/admin/weddings")
}
```
  </action>
  <verify>
- All files created in src/app/(platform)/admin/
- `npx tsc --noEmit` passes
- Admin layout checks role === "admin"
- createWeddingSite uses $transaction for atomicity
  </verify>
  <done>Admin dashboard shows all weddings, can create new wedding sites with couple accounts in single transaction</done>
</task>

<task type="auto">
  <name>Task 3: Create seed script for initial admin user</name>
  <files>
    - prisma/seed.ts
    - package.json
  </files>
  <action>
Create prisma/seed.ts:
```typescript
import { PrismaClient } from "@prisma/client"
import bcrypt from "bcryptjs"

const prisma = new PrismaClient()

async function main() {
  // Create admin user if doesn't exist
  const adminEmail = process.env.ADMIN_EMAIL || "admin@wedding-platform.local"
  const adminPassword = process.env.ADMIN_PASSWORD || "admin123456"

  const existingAdmin = await prisma.user.findUnique({
    where: { email: adminEmail },
  })

  if (!existingAdmin) {
    const hashedPassword = await bcrypt.hash(adminPassword, 12)

    await prisma.user.create({
      data: {
        email: adminEmail,
        hashedPassword,
        name: "Platform Admin",
        role: "admin",
        // Admin has no tenantId - they access all tenants
      },
    })

    console.log(`Created admin user: ${adminEmail}`)
  } else {
    console.log(`Admin user already exists: ${adminEmail}`)
  }

  // Optionally create a test wedding
  const testSubdomain = "demo"
  const existingTenant = await prisma.tenant.findUnique({
    where: { subdomain: testSubdomain },
  })

  if (!existingTenant) {
    const tenant = await prisma.tenant.create({
      data: {
        subdomain: testSubdomain,
        name: "Demo Wedding",
      },
    })

    await prisma.wedding.create({
      data: {
        tenantId: tenant.id,
        partner1Name: "Alice",
        partner2Name: "Bob",
      },
    })

    const couplePassword = await bcrypt.hash("demo123456", 12)
    await prisma.user.create({
      data: {
        email: "demo@wedding-platform.local",
        hashedPassword: couplePassword,
        name: "Alice & Bob",
        role: "couple",
        tenantId: tenant.id,
      },
    })

    console.log("Created demo wedding: demo.localhost:3000")
    console.log("Demo couple login: demo@wedding-platform.local / demo123456")
  }
}

main()
  .then(async () => {
    await prisma.$disconnect()
  })
  .catch(async (e) => {
    console.error(e)
    await prisma.$disconnect()
    process.exit(1)
  })
```

Update package.json to add seed script in prisma config:
```json
{
  "prisma": {
    "seed": "npx tsx prisma/seed.ts"
  }
}
```

Also ensure tsx is available (may already be from Next.js):
```bash
npm install -D tsx
```
  </action>
  <verify>
- prisma/seed.ts exists with admin user creation
- package.json has prisma.seed configured
- `npx tsc --noEmit` passes (seed.ts compiles)
  </verify>
  <done>Seed script creates admin user and optional demo wedding, can be run with `npx prisma db seed`</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npx tsc --noEmit` passes
2. Login page renders at /login
3. Admin layout protects /admin/* routes with role check
4. Admin dashboard page shows wedding/user counts
5. Wedding list page displays all weddings
6. Create wedding form submits and creates tenant/wedding/user atomically
7. Seed script compiles and can create admin user
</verification>

<success_criteria>
- Admin can access /login and submit credentials
- Admin role check in layout (defense-in-depth beyond middleware)
- Admin dashboard at /admin shows total weddings and users
- Admin can view list of all weddings at /admin/weddings
- Admin can create new wedding site at /admin/weddings/new
- Creating wedding atomically creates Tenant, Wedding, and User (couple)
- Seed script available to bootstrap admin account
- Non-admin users redirected away from /admin routes
</success_criteria>

<output>
After completion, create `.planning/phases/02-admin-couple-auth/02-02-SUMMARY.md`
</output>
