---
phase: 09-seating-chart
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - wedding-platform/prisma/schema.prisma
  - wedding-platform/src/app/(platform)/dashboard/seating/actions.ts
autonomous: true

must_haves:
  truths:
    - "Table model exists with name, capacity, and wedding relation"
    - "SeatAssignment model links guests to tables with cascade delete"
    - "Server actions support table CRUD operations"
    - "Server action assigns guest to table with capacity validation"
  artifacts:
    - path: "wedding-platform/prisma/schema.prisma"
      provides: "Table and SeatAssignment models"
      contains: "model Table"
    - path: "wedding-platform/src/app/(platform)/dashboard/seating/actions.ts"
      provides: "Server actions for seating management"
      exports: ["createTable", "updateTable", "deleteTable", "assignGuestToTable"]
  key_links:
    - from: "SeatAssignment"
      to: "Guest"
      via: "guestId with cascade delete"
      pattern: "onDelete: Cascade"
    - from: "SeatAssignment"
      to: "Table"
      via: "tableId with cascade delete"
      pattern: "onDelete: Cascade"
---

<objective>
Create the database schema and server actions for seating chart management.

Purpose: Establish the data layer that powers table management and guest assignment.
Output: Table and SeatAssignment models in Prisma, server actions for CRUD and assignment.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@wedding-platform/.planning/PROJECT.md
@wedding-platform/.planning/ROADMAP.md
@wedding-platform/.planning/STATE.md
@wedding-platform/.planning/phases/09-seating-chart/09-RESEARCH.md

# Existing patterns
@wedding-platform/prisma/schema.prisma
@wedding-platform/src/app/(platform)/dashboard/guests/actions.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Table and SeatAssignment models to schema</name>
  <files>wedding-platform/prisma/schema.prisma</files>
  <action>
Add two new models to the Prisma schema:

1. **Table model:**
```prisma
model Table {
  id        String   @id @default(cuid())
  weddingId String
  wedding   Wedding  @relation(fields: [weddingId], references: [id], onDelete: Cascade)

  name      String   // "Table 1", "Head Table", etc.
  capacity  Int      // Maximum seats (headcount including plus-ones)

  order     Int      @default(0)  // Display ordering

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  seatAssignments SeatAssignment[]

  @@index([weddingId])
}
```

2. **SeatAssignment model:**
```prisma
model SeatAssignment {
  id        String   @id @default(cuid())
  tableId   String
  table     Table    @relation(fields: [tableId], references: [id], onDelete: Cascade)
  guestId   String   @unique  // Guest can only be at one table
  guest     Guest    @relation(fields: [guestId], references: [id], onDelete: Cascade)

  assignedAt DateTime @default(now())

  @@unique([tableId, guestId])
  @@index([tableId])
  @@index([guestId])
}
```

3. **Update Wedding model** - add `tables Table[]` relation

4. **Update Guest model** - add `seatAssignment SeatAssignment?` relation

Run `npx prisma db push` after schema changes.
  </action>
  <verify>
`npx prisma db push` succeeds without errors.
`npx prisma generate` creates updated client types.
  </verify>
  <done>Table and SeatAssignment models exist with proper relations and cascade deletes.</done>
</task>

<task type="auto">
  <name>Task 2: Create seating server actions</name>
  <files>wedding-platform/src/app/(platform)/dashboard/seating/actions.ts</files>
  <action>
Create server actions following the established pattern (see guests/actions.ts):

1. **createTable(formData: FormData):**
   - Validate: name (required string), capacity (required int >= 1)
   - Use `withTenantContext` for tenant isolation
   - Get wedding, create table with order = max(existing orders) + 1
   - Revalidate `/dashboard/seating`
   - Return `{ success: true, tableId }` or `{ success: false, error }`

2. **updateTable(tableId: string, formData: FormData):**
   - Validate same fields as create
   - Verify table belongs to tenant's wedding
   - Update name and capacity
   - Revalidate paths
   - Return success/error

3. **deleteTable(tableId: string):**
   - Verify table belongs to tenant
   - Delete (SeatAssignments cascade)
   - Revalidate path
   - Return success/error

4. **assignGuestToTable(guestId: string, tableId: string | null):**
   - If tableId is null, delete assignment (unassign)
   - If assigning: check table capacity (sum of 1 + plusOneCount for current + new guest)
   - Use upsert for assignment (handles move between tables)
   - Return `{ success: true }` or `{ success: false, error: "Table is at capacity" }`

5. **reorderTables(orderedIds: string[]):**
   - Update order field for each table
   - Revalidate path

Use Zod for validation. Follow existing error handling patterns.
  </action>
  <verify>
File compiles without TypeScript errors.
Actions import correctly from dashboard/seating/actions.
  </verify>
  <done>
Server actions exist for: createTable, updateTable, deleteTable, assignGuestToTable, reorderTables.
Capacity validation includes plus-ones.
Tenant isolation via withTenantContext.
  </done>
</task>

</tasks>

<verification>
1. `npx prisma db push` completes successfully
2. `npm run build` passes (no type errors)
3. Schema includes Table and SeatAssignment models with correct relations
4. Actions file exports all required functions
</verification>

<success_criteria>
- Table model exists with name, capacity, weddingId, order
- SeatAssignment links Guest to Table with unique constraint on guestId
- Cascade delete configured for both guest and table deletion
- Server actions handle CRUD for tables and guest assignment
- Capacity validation accounts for plus-ones
</success_criteria>

<output>
After completion, create `.planning/phases/09-seating-chart/09-01-SUMMARY.md`
</output>
