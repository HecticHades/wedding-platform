---
phase: 10-custom-domains-polish
plan: 02
type: execute
wave: 2
depends_on: ["10-01"]
files_modified:
  - wedding-platform/src/app/api/domains/add/route.ts
  - wedding-platform/src/app/api/domains/verify/route.ts
  - wedding-platform/src/app/api/domains/remove/route.ts
  - wedding-platform/src/app/api/domains/status/route.ts
  - wedding-platform/src/app/api/internal/tenant-lookup/route.ts
  - wedding-platform/src/proxy.ts
autonomous: true

must_haves:
  truths:
    - "API routes handle domain add/verify/remove/status operations"
    - "Tenant lookup API returns tenant for custom domain"
    - "Custom domain requests route to correct tenant site"
    - "Existing subdomain routing continues to work"
    - "API routes require authentication"
  artifacts:
    - path: "wedding-platform/src/app/api/domains/add/route.ts"
      provides: "POST endpoint to add custom domain"
      exports: ["POST"]
    - path: "wedding-platform/src/app/api/domains/verify/route.ts"
      provides: "POST endpoint to trigger verification"
      exports: ["POST"]
    - path: "wedding-platform/src/app/api/domains/remove/route.ts"
      provides: "DELETE endpoint to remove domain"
      exports: ["DELETE"]
    - path: "wedding-platform/src/app/api/domains/status/route.ts"
      provides: "GET endpoint to check domain status"
      exports: ["GET"]
    - path: "wedding-platform/src/app/api/internal/tenant-lookup/route.ts"
      provides: "Internal API for Edge middleware tenant lookup"
      exports: ["GET"]
    - path: "wedding-platform/src/proxy.ts"
      provides: "Extended middleware for custom domain routing"
      contains: "isCustomDomain"
  key_links:
    - from: "wedding-platform/src/app/api/domains/add/route.ts"
      to: "wedding-platform/src/lib/domains/domain-service.ts"
      via: "addCustomDomain import"
      pattern: "import.*addCustomDomain.*from"
    - from: "wedding-platform/src/proxy.ts"
      to: "/api/internal/tenant-lookup"
      via: "fetch for custom domain resolution"
      pattern: "fetch.*api/internal/tenant-lookup"
---

<objective>
Create API routes for domain management and extend middleware for custom domain routing.

Purpose: Enable programmatic domain configuration from the UI and ensure custom domains route correctly to tenant sites. The API routes call the domain service from Plan 01, and the middleware extension allows guests to access wedding sites via custom domains.

Output: Domain management API routes (add, verify, remove, status), internal tenant lookup API, and extended proxy.ts supporting custom domain routing alongside existing subdomain routing.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@wedding-platform/.planning/PROJECT.md
@wedding-platform/.planning/ROADMAP.md
@wedding-platform/.planning/STATE.md
@wedding-platform/.planning/phases/10-custom-domains-polish/10-RESEARCH.md
@wedding-platform/src/proxy.ts
@wedding-platform/src/lib/auth/auth.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create domain management API routes</name>
  <files>
    wedding-platform/src/app/api/domains/add/route.ts
    wedding-platform/src/app/api/domains/verify/route.ts
    wedding-platform/src/app/api/domains/remove/route.ts
    wedding-platform/src/app/api/domains/status/route.ts
  </files>
  <action>
1. Create wedding-platform/src/app/api/domains/add/route.ts:
   ```typescript
   import { auth } from "@/lib/auth/auth"
   import { addCustomDomain } from "@/lib/domains/domain-service"
   import { NextResponse } from "next/server"
   import { z } from "zod"

   const addDomainSchema = z.object({
     domain: z
       .string()
       .min(4)
       .max(253)
       .regex(
         /^(?!-)[A-Za-z0-9-]+(\.[A-Za-z0-9-]+)*\.[A-Za-z]{2,}$/,
         "Invalid domain format"
       ),
   })

   export async function POST(request: Request) {
     const session = await auth()

     if (!session?.user?.tenantId) {
       return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
     }

     try {
       const body = await request.json()
       const { domain } = addDomainSchema.parse(body)

       const result = await addCustomDomain(session.user.tenantId, domain)

       if (!result.success) {
         return NextResponse.json({ error: result.error }, { status: 400 })
       }

       return NextResponse.json({
         success: true,
         verified: result.verified,
         dnsInstructions: result.dnsInstructions,
         txtVerification: result.txtVerification,
       })
     } catch (error) {
       if (error instanceof z.ZodError) {
         return NextResponse.json(
           { error: error.errors[0].message },
           { status: 400 }
         )
       }
       console.error("Add domain error:", error)
       return NextResponse.json(
         { error: "Failed to add domain" },
         { status: 500 }
       )
     }
   }
   ```

2. Create wedding-platform/src/app/api/domains/verify/route.ts:
   ```typescript
   import { auth } from "@/lib/auth/auth"
   import { verifyDomain } from "@/lib/domains/domain-service"
   import { NextResponse } from "next/server"

   export async function POST() {
     const session = await auth()

     if (!session?.user?.tenantId) {
       return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
     }

     try {
       const result = await verifyDomain(session.user.tenantId)

       if (!result.success) {
         return NextResponse.json({ error: result.error }, { status: 400 })
       }

       return NextResponse.json({
         success: true,
         verified: result.verified,
       })
     } catch (error) {
       console.error("Verify domain error:", error)
       return NextResponse.json(
         { error: "Failed to verify domain" },
         { status: 500 }
       )
     }
   }
   ```

3. Create wedding-platform/src/app/api/domains/remove/route.ts:
   ```typescript
   import { auth } from "@/lib/auth/auth"
   import { removeDomain } from "@/lib/domains/domain-service"
   import { NextResponse } from "next/server"

   export async function DELETE() {
     const session = await auth()

     if (!session?.user?.tenantId) {
       return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
     }

     try {
       const result = await removeDomain(session.user.tenantId)

       if (!result.success) {
         return NextResponse.json({ error: result.error }, { status: 400 })
       }

       return NextResponse.json({ success: true })
     } catch (error) {
       console.error("Remove domain error:", error)
       return NextResponse.json(
         { error: "Failed to remove domain" },
         { status: 500 }
       )
     }
   }
   ```

4. Create wedding-platform/src/app/api/domains/status/route.ts:
   ```typescript
   import { auth } from "@/lib/auth/auth"
   import { getDomainStatus } from "@/lib/domains/domain-service"
   import { NextResponse } from "next/server"

   export async function GET() {
     const session = await auth()

     if (!session?.user?.tenantId) {
       return NextResponse.json({ error: "Unauthorized" }, { status: 401 })
     }

     try {
       const status = await getDomainStatus(session.user.tenantId)

       return NextResponse.json(status)
     } catch (error) {
       console.error("Get domain status error:", error)
       return NextResponse.json(
         { error: "Failed to get domain status" },
         { status: 500 }
       )
     }
   }
   ```
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - All four route files exist in wedding-platform/src/app/api/domains/
    - Each route exports the correct HTTP method handler
  </verify>
  <done>Domain management API routes created with authentication and proper error handling</done>
</task>

<task type="auto">
  <name>Task 2: Create internal tenant lookup API and extend proxy.ts</name>
  <files>
    wedding-platform/src/app/api/internal/tenant-lookup/route.ts
    wedding-platform/src/proxy.ts
  </files>
  <action>
1. Create wedding-platform/src/app/api/internal/tenant-lookup/route.ts - Internal API for Edge middleware:
   ```typescript
   import { prisma } from "@/lib/db/prisma"
   import { NextRequest, NextResponse } from "next/server"
   import { DomainStatus } from "@prisma/client"

   /**
    * Internal API for tenant lookup by custom domain
    * Called from middleware (Edge runtime) which cannot access Prisma directly
    *
    * Only returns tenant if domain is verified
    */
   export async function GET(request: NextRequest) {
     const domain = request.nextUrl.searchParams.get("domain")

     if (!domain) {
       return NextResponse.json({ error: "Domain required" }, { status: 400 })
     }

     try {
       const tenant = await prisma.tenant.findUnique({
         where: { customDomain: domain.toLowerCase() },
         select: {
           id: true,
           subdomain: true,
           customDomain: true,
           domainStatus: true,
         },
       })

       // Only return tenant if domain is verified
       if (!tenant || tenant.domainStatus !== DomainStatus.VERIFIED) {
         return NextResponse.json({ tenant: null })
       }

       return NextResponse.json({
         tenant: {
           id: tenant.id,
           subdomain: tenant.subdomain,
           customDomain: tenant.customDomain,
         },
       })
     } catch (error) {
       console.error("Tenant lookup error:", error)
       return NextResponse.json({ error: "Lookup failed" }, { status: 500 })
     }
   }
   ```

2. Update wedding-platform/src/proxy.ts to handle custom domains:
   ```typescript
   import { auth } from "@/lib/auth/auth"
   import { NextResponse } from "next/server"

   export default auth(async (req) => {
     const { nextUrl, auth: session } = req
     const isLoggedIn = !!session?.user
     const isAdmin = session?.user?.role === "admin"

     // Auth route protection
     if (nextUrl.pathname.startsWith("/admin")) {
       if (!isLoggedIn) {
         return NextResponse.redirect(new URL("/login", nextUrl.origin))
       }
       if (!isAdmin) {
         return NextResponse.redirect(new URL("/dashboard", nextUrl.origin))
       }
     }

     if (nextUrl.pathname.startsWith("/dashboard")) {
       if (!isLoggedIn) {
         return NextResponse.redirect(new URL("/login", nextUrl.origin))
       }
       // Admin trying to access dashboard goes to admin
       if (isAdmin) {
         return NextResponse.redirect(new URL("/admin", nextUrl.origin))
       }
     }

     // Redirect logged-in users away from login page
     if (nextUrl.pathname === "/login" && isLoggedIn) {
       const redirectTo = isAdmin ? "/admin" : "/dashboard"
       return NextResponse.redirect(new URL(redirectTo, nextUrl.origin))
     }

     // Hostname-based routing (subdomain or custom domain)
     const hostname = req.headers.get("host") || ""
     const rootDomain = process.env.NEXT_PUBLIC_ROOT_DOMAIN || "localhost:3000"

     let subdomain: string | null = null

     // Production: alice-bob.weddingplatform.com -> alice-bob
     if (hostname.endsWith(`.${rootDomain}`) && !hostname.startsWith("www.")) {
       subdomain = hostname.replace(`.${rootDomain}`, "")
     }

     // Development: alice-bob.localhost:3000 -> alice-bob
     if (hostname.includes("localhost") && hostname !== "localhost:3000" && hostname !== "localhost") {
       subdomain = hostname.split(".")[0]
     }

     // Subdomain detected - rewrite to tenant route
     if (subdomain) {
       return NextResponse.rewrite(new URL(`/${subdomain}${nextUrl.pathname}`, req.url))
     }

     // Check for custom domain (not subdomain, not root, not localhost dev)
     const isCustomDomain =
       !hostname.endsWith(`.${rootDomain}`) &&
       hostname !== rootDomain &&
       !hostname.includes("localhost") &&
       !hostname.startsWith("www.")

     if (isCustomDomain) {
       try {
         // Lookup tenant by custom domain via internal API
         // We use fetch because middleware runs in Edge runtime and cannot use Prisma directly
         const lookupUrl = new URL("/api/internal/tenant-lookup", req.url)
         lookupUrl.searchParams.set("domain", hostname)

         const response = await fetch(lookupUrl.toString())
         const data = await response.json()

         if (data.tenant?.subdomain) {
           // Rewrite to tenant route using their subdomain
           return NextResponse.rewrite(
             new URL(`/${data.tenant.subdomain}${nextUrl.pathname}`, req.url)
           )
         }

         // Custom domain not found or not verified - show error page
         // Could redirect to a "domain not configured" page on root domain
         console.warn(`Custom domain not found or not verified: ${hostname}`)
       } catch (error) {
         console.error("Custom domain lookup failed:", error)
       }
     }

     return NextResponse.next()
   })

   export const config = {
     matcher: [
       // Match all paths except static files, api/auth, api/internal, and Next.js internals
       "/((?!api/auth|api/internal|_next/static|_next/image|favicon.ico|robots.txt|sitemap.xml).*)",
     ],
   }
   ```

Note: The matcher is updated to exclude api/internal routes to prevent recursive calls from the middleware.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - wedding-platform/src/app/api/internal/tenant-lookup/route.ts exists
    - proxy.ts contains `isCustomDomain` logic
    - proxy.ts contains fetch to `/api/internal/tenant-lookup`
    - matcher excludes `api/internal`
  </verify>
  <done>Internal tenant lookup API created, proxy.ts extended to route custom domains to correct tenant</done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `npx tsc --noEmit` compiles without errors
2. API routes exist:
   - wedding-platform/src/app/api/domains/add/route.ts
   - wedding-platform/src/app/api/domains/verify/route.ts
   - wedding-platform/src/app/api/domains/remove/route.ts
   - wedding-platform/src/app/api/domains/status/route.ts
   - wedding-platform/src/app/api/internal/tenant-lookup/route.ts
3. proxy.ts handles both subdomain and custom domain routing
4. matcher excludes api/internal to prevent recursive calls
</verification>

<success_criteria>
- Domain add/verify/remove/status API routes functional with authentication
- Internal tenant lookup returns verified domains only
- Custom domain requests rewrite to correct tenant subdomain route
- Existing subdomain routing unaffected
- Edge middleware works without Prisma (uses internal API)
</success_criteria>

<output>
After completion, create `.planning/phases/10-custom-domains-polish/10-02-SUMMARY.md`
</output>
