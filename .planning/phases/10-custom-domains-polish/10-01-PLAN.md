---
phase: 10-custom-domains-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - wedding-platform/package.json
  - wedding-platform/prisma/schema.prisma
  - wedding-platform/src/lib/domains/vercel-client.ts
  - wedding-platform/src/lib/domains/domain-service.ts
  - wedding-platform/src/lib/domains/dns-instructions.ts
autonomous: true
user_setup:
  - service: vercel
    why: "Programmatic domain management via Vercel API"
    env_vars:
      - name: VERCEL_API_TOKEN
        source: "Vercel Dashboard -> Settings -> Tokens -> Create"
      - name: VERCEL_PROJECT_ID
        source: "Vercel Dashboard -> Project -> Settings -> General -> Project ID"
      - name: VERCEL_TEAM_ID
        source: "Vercel Dashboard -> Settings -> General -> Team ID (if using team)"

must_haves:
  truths:
    - "DomainStatus enum exists with NONE, PENDING, VERIFYING, VERIFIED, FAILED states"
    - "Tenant model has domain management fields"
    - "Domain service can add domains to Vercel project"
    - "Domain service can check verification status"
    - "Domain service can remove domains from Vercel project"
    - "DNS instructions are generated based on apex vs subdomain"
  artifacts:
    - path: "wedding-platform/prisma/schema.prisma"
      provides: "DomainStatus enum and Tenant domain fields"
      contains: "enum DomainStatus"
    - path: "wedding-platform/src/lib/domains/vercel-client.ts"
      provides: "Vercel SDK singleton"
      exports: ["vercel"]
    - path: "wedding-platform/src/lib/domains/domain-service.ts"
      provides: "Domain management business logic"
      exports: ["addCustomDomain", "verifyDomain", "removeDomain", "getDomainStatus"]
    - path: "wedding-platform/src/lib/domains/dns-instructions.ts"
      provides: "DNS instruction generation"
      exports: ["getDnsInstructions"]
  key_links:
    - from: "wedding-platform/src/lib/domains/domain-service.ts"
      to: "@vercel/sdk"
      via: "Vercel client import"
      pattern: "import.*from.*@vercel/sdk"
    - from: "wedding-platform/src/lib/domains/domain-service.ts"
      to: "prisma"
      via: "Database update after Vercel operations"
      pattern: "prisma\\.tenant\\.(update|findUnique)"
---

<objective>
Install Vercel SDK and create domain management infrastructure.

Purpose: Establish the foundation for custom domain support by adding the necessary database schema, Vercel API integration, and business logic layer. This enables subsequent plans to build API routes and UI on top of this foundation.

Output: DomainStatus enum, Tenant model domain fields, Vercel client singleton, domain service with add/verify/remove/status operations, and DNS instruction generator.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@wedding-platform/.planning/PROJECT.md
@wedding-platform/.planning/ROADMAP.md
@wedding-platform/.planning/STATE.md
@wedding-platform/.planning/phases/10-custom-domains-polish/10-RESEARCH.md
@wedding-platform/prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Vercel SDK and update schema</name>
  <files>
    wedding-platform/package.json
    wedding-platform/prisma/schema.prisma
  </files>
  <action>
1. Install @vercel/sdk:
   ```bash
   cd wedding-platform && npm install @vercel/sdk
   ```

2. Add DomainStatus enum to prisma/schema.prisma (after existing enums):
   ```prisma
   // Domain verification status for custom domains
   enum DomainStatus {
     NONE       // No custom domain configured
     PENDING    // Domain added, awaiting DNS configuration
     VERIFYING  // DNS configured, verification in progress
     VERIFIED   // Domain verified and active
     FAILED     // Verification failed
   }
   ```

3. Add domain management fields to Tenant model:
   ```prisma
   model Tenant {
     id           String    @id @default(cuid())
     subdomain    String    @unique
     customDomain String?   @unique
     name         String

     // Domain management fields
     domainStatus       DomainStatus @default(NONE)
     domainVerification Json?        // Store verification challenges from Vercel
     domainAddedAt      DateTime?    // When domain was added
     domainVerifiedAt   DateTime?    // When domain was verified

     createdAt    DateTime  @default(now())
     updatedAt    DateTime  @updatedAt

     // Relations
     wedding      Wedding?
     user         User?
   }
   ```

4. Run prisma db push to apply changes:
   ```bash
   cd wedding-platform && npx prisma db push
   ```

5. Generate updated Prisma client:
   ```bash
   cd wedding-platform && npx prisma generate
   ```
  </action>
  <verify>
    - `npm ls @vercel/sdk` shows package installed
    - `npx prisma validate` passes without errors
    - `npx prisma db push` completes successfully
  </verify>
  <done>DomainStatus enum and Tenant domain fields exist in schema, @vercel/sdk installed</done>
</task>

<task type="auto">
  <name>Task 2: Create Vercel client and domain service</name>
  <files>
    wedding-platform/src/lib/domains/vercel-client.ts
    wedding-platform/src/lib/domains/domain-service.ts
    wedding-platform/src/lib/domains/dns-instructions.ts
  </files>
  <action>
1. Create wedding-platform/src/lib/domains/vercel-client.ts - Vercel SDK singleton:
   ```typescript
   import { Vercel } from "@vercel/sdk"

   // Singleton Vercel client
   // Note: @vercel/sdk is ESM-only
   export const vercel = new Vercel({
     bearerToken: process.env.VERCEL_API_TOKEN!,
   })

   // Configuration from environment
   export const vercelConfig = {
     projectId: process.env.VERCEL_PROJECT_ID!,
     teamId: process.env.VERCEL_TEAM_ID || undefined, // Optional for personal accounts
   }
   ```

2. Create wedding-platform/src/lib/domains/dns-instructions.ts - DNS instruction generator:
   ```typescript
   export interface DnsInstructions {
     recordType: "A" | "CNAME"
     name: string
     value: string
     instructions: string
     isApex: boolean
   }

   export interface TxtVerification {
     type: "TXT"
     name: string
     value: string
     reason: string
   }

   /**
    * Generate DNS instructions based on domain type (apex vs subdomain)
    * Apex domains (example.com) need A record
    * Subdomains (www.example.com) need CNAME record
    */
   export function getDnsInstructions(domain: string): DnsInstructions {
     const parts = domain.split(".")
     const isApex = parts.length === 2 || (parts.length === 3 && parts[0] === "www")

     if (isApex) {
       return {
         recordType: "A",
         name: "@",
         value: "76.76.21.21", // Vercel's IP address
         instructions: "Add an A record pointing your domain to Vercel's IP address. This allows your apex domain to work with Vercel.",
         isApex: true,
       }
     } else {
       // Subdomain - extract the subdomain part
       const subdomain = parts[0]
       return {
         recordType: "CNAME",
         name: subdomain,
         value: "cname.vercel-dns.com",
         instructions: `Add a CNAME record for "${subdomain}" pointing to Vercel's DNS. This allows your subdomain to work with Vercel.`,
         isApex: false,
       }
     }
   }

   /**
    * Parse TXT verification challenge from Vercel API response
    */
   export function getTxtVerification(
     verification: Array<{ type: string; domain: string; value: string }> | null | undefined
   ): TxtVerification | null {
     if (!verification) return null

     const txtRecord = verification.find((v) => v.type === "TXT")
     if (!txtRecord) return null

     return {
       type: "TXT",
       name: "_vercel",
       value: txtRecord.value,
       reason: "This domain was previously used on Vercel. Add this TXT record to verify ownership.",
     }
   }
   ```

3. Create wedding-platform/src/lib/domains/domain-service.ts - Domain management service:
   ```typescript
   import { vercel, vercelConfig } from "./vercel-client"
   import { getDnsInstructions, getTxtVerification, DnsInstructions, TxtVerification } from "./dns-instructions"
   import { prisma } from "@/lib/db/prisma"
   import { DomainStatus } from "@prisma/client"

   export interface AddDomainResult {
     success: boolean
     verified: boolean
     dnsInstructions: DnsInstructions
     txtVerification: TxtVerification | null
     error?: string
   }

   export interface DomainStatusResult {
     status: DomainStatus
     customDomain: string | null
     verified: boolean
     dnsInstructions: DnsInstructions | null
     txtVerification: TxtVerification | null
     addedAt: Date | null
     verifiedAt: Date | null
   }

   /**
    * Add a custom domain to a tenant
    * 1. Add domain to Vercel project
    * 2. Store in database with pending status
    * 3. Return DNS instructions for the couple
    */
   export async function addCustomDomain(
     tenantId: string,
     domain: string
   ): Promise<AddDomainResult> {
     // Normalize domain (lowercase, no trailing dots)
     const normalizedDomain = domain.toLowerCase().replace(/\.$/, "")

     try {
       // Check if domain already exists on another tenant
       const existingTenant = await prisma.tenant.findUnique({
         where: { customDomain: normalizedDomain },
       })

       if (existingTenant && existingTenant.id !== tenantId) {
         return {
           success: false,
           verified: false,
           dnsInstructions: getDnsInstructions(normalizedDomain),
           txtVerification: null,
           error: "This domain is already in use by another wedding site.",
         }
       }

       // Add domain to Vercel project
       const result = await vercel.projects.addProjectDomain({
         idOrName: vercelConfig.projectId,
         teamId: vercelConfig.teamId,
         requestBody: {
           name: normalizedDomain,
         },
       })

       // Update tenant in database
       await prisma.tenant.update({
         where: { id: tenantId },
         data: {
           customDomain: normalizedDomain,
           domainStatus: result.verified ? DomainStatus.VERIFIED : DomainStatus.PENDING,
           domainVerification: result.verification as unknown as object ?? null,
           domainAddedAt: new Date(),
           domainVerifiedAt: result.verified ? new Date() : null,
         },
       })

       return {
         success: true,
         verified: result.verified ?? false,
         dnsInstructions: getDnsInstructions(normalizedDomain),
         txtVerification: getTxtVerification(result.verification as Array<{ type: string; domain: string; value: string }> | undefined),
       }
     } catch (error) {
       console.error("Failed to add custom domain:", error)

       // Handle specific Vercel API errors
       const errorMessage = error instanceof Error ? error.message : "Unknown error"

       return {
         success: false,
         verified: false,
         dnsInstructions: getDnsInstructions(normalizedDomain),
         txtVerification: null,
         error: `Failed to add domain: ${errorMessage}`,
       }
     }
   }

   /**
    * Verify a custom domain
    * Triggers Vercel to check DNS configuration
    */
   export async function verifyDomain(tenantId: string): Promise<{
     success: boolean
     verified: boolean
     error?: string
   }> {
     const tenant = await prisma.tenant.findUnique({
       where: { id: tenantId },
     })

     if (!tenant?.customDomain) {
       return { success: false, verified: false, error: "No custom domain configured" }
     }

     try {
       const result = await vercel.projects.verifyProjectDomain({
         idOrName: vercelConfig.projectId,
         domain: tenant.customDomain,
         teamId: vercelConfig.teamId,
       })

       const newStatus = result.verified
         ? DomainStatus.VERIFIED
         : DomainStatus.VERIFYING

       await prisma.tenant.update({
         where: { id: tenantId },
         data: {
           domainStatus: newStatus,
           domainVerifiedAt: result.verified ? new Date() : null,
         },
       })

       return {
         success: true,
         verified: result.verified ?? false,
       }
     } catch (error) {
       console.error("Failed to verify domain:", error)

       await prisma.tenant.update({
         where: { id: tenantId },
         data: { domainStatus: DomainStatus.FAILED },
       })

       return {
         success: false,
         verified: false,
         error: error instanceof Error ? error.message : "Verification failed",
       }
     }
   }

   /**
    * Remove a custom domain from a tenant
    */
   export async function removeDomain(tenantId: string): Promise<{
     success: boolean
     error?: string
   }> {
     const tenant = await prisma.tenant.findUnique({
       where: { id: tenantId },
     })

     if (!tenant?.customDomain) {
       return { success: false, error: "No custom domain configured" }
     }

     try {
       await vercel.projects.removeProjectDomain({
         idOrName: vercelConfig.projectId,
         domain: tenant.customDomain,
         teamId: vercelConfig.teamId,
       })

       await prisma.tenant.update({
         where: { id: tenantId },
         data: {
           customDomain: null,
           domainStatus: DomainStatus.NONE,
           domainVerification: null,
           domainAddedAt: null,
           domainVerifiedAt: null,
         },
       })

       return { success: true }
     } catch (error) {
       console.error("Failed to remove domain:", error)
       return {
         success: false,
         error: error instanceof Error ? error.message : "Failed to remove domain",
       }
     }
   }

   /**
    * Get current domain status for a tenant
    */
   export async function getDomainStatus(tenantId: string): Promise<DomainStatusResult> {
     const tenant = await prisma.tenant.findUnique({
       where: { id: tenantId },
     })

     if (!tenant) {
       return {
         status: DomainStatus.NONE,
         customDomain: null,
         verified: false,
         dnsInstructions: null,
         txtVerification: null,
         addedAt: null,
         verifiedAt: null,
       }
     }

     return {
       status: tenant.domainStatus,
       customDomain: tenant.customDomain,
       verified: tenant.domainStatus === DomainStatus.VERIFIED,
       dnsInstructions: tenant.customDomain
         ? getDnsInstructions(tenant.customDomain)
         : null,
       txtVerification: tenant.domainVerification
         ? getTxtVerification(tenant.domainVerification as Array<{ type: string; domain: string; value: string }>)
         : null,
       addedAt: tenant.domainAddedAt,
       verifiedAt: tenant.domainVerifiedAt,
     }
   }
   ```
  </action>
  <verify>
    - `npx tsc --noEmit` passes without type errors
    - All three files exist in wedding-platform/src/lib/domains/
    - domain-service.ts exports addCustomDomain, verifyDomain, removeDomain, getDomainStatus
    - dns-instructions.ts exports getDnsInstructions, getTxtVerification
    - vercel-client.ts exports vercel, vercelConfig
  </verify>
  <done>Vercel client singleton created, domain service with full CRUD operations, DNS instruction generator functional</done>
</task>

<task type="auto">
  <name>Task 3: Update .env.example with Vercel configuration</name>
  <files>
    wedding-platform/.env.example
  </files>
  <action>
Add Vercel API configuration to .env.example:

```
# Vercel API (for custom domain management)
VERCEL_API_TOKEN=           # Vercel Dashboard -> Settings -> Tokens -> Create
VERCEL_PROJECT_ID=          # Vercel Dashboard -> Project -> Settings -> General -> Project ID
VERCEL_TEAM_ID=             # Optional: Vercel Dashboard -> Settings -> General -> Team ID
```
  </action>
  <verify>
    - .env.example contains VERCEL_API_TOKEN, VERCEL_PROJECT_ID, VERCEL_TEAM_ID entries
  </verify>
  <done>.env.example documents all required Vercel environment variables</done>
</task>

</tasks>

<verification>
After completing all tasks:
1. `npm ls @vercel/sdk` shows @vercel/sdk installed
2. `npx prisma validate` passes
3. `npx tsc --noEmit` compiles without errors
4. Files exist:
   - wedding-platform/src/lib/domains/vercel-client.ts
   - wedding-platform/src/lib/domains/domain-service.ts
   - wedding-platform/src/lib/domains/dns-instructions.ts
5. DomainStatus enum exists in schema with 5 states
</verification>

<success_criteria>
- Vercel SDK installed and configured
- DomainStatus enum with NONE/PENDING/VERIFYING/VERIFIED/FAILED states
- Tenant model has domainStatus, domainVerification, domainAddedAt, domainVerifiedAt fields
- Domain service exports addCustomDomain, verifyDomain, removeDomain, getDomainStatus
- DNS instructions generated correctly for apex vs subdomain
- Environment variables documented in .env.example
</success_criteria>

<output>
After completion, create `.planning/phases/10-custom-domains-polish/10-01-SUMMARY.md`
</output>
