---
phase: 01-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/lib/db/prisma.ts
  - src/lib/db/tenant-context.ts
  - src/app/[domain]/page.tsx
autonomous: true

must_haves:
  truths:
    - "Database queries return only data belonging to the current tenant"
    - "Concurrent users on different subdomains see only their own tenant data"
    - "Attempting to access another tenant's data returns empty results"
  artifacts:
    - path: "src/lib/db/prisma.ts"
      provides: "Tenant-aware Prisma client"
      contains: "$extends"
    - path: "src/lib/db/tenant-context.ts"
      provides: "AsyncLocalStorage tenant context"
      contains: "AsyncLocalStorage"
  key_links:
    - from: "src/app/[domain]/page.tsx"
      to: "src/lib/db/prisma.ts"
      via: "prisma import and tenant-scoped query"
      pattern: "prisma\\.(tenant|wedding)"
    - from: "src/lib/db/prisma.ts"
      to: "src/lib/db/tenant-context.ts"
      via: "getTenantContext call"
      pattern: "getTenantContext"
---

<objective>
Implement tenant isolation at the application level using Prisma client extensions and AsyncLocalStorage context.

Purpose: Ensure that tenant data cannot leak between weddings - a critical security requirement. Application-level isolation via Prisma extensions provides the primary defense layer.
Output: Tenant-aware Prisma client that automatically scopes queries to the current tenant.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create tenant context with AsyncLocalStorage</name>
  <files>
    src/lib/db/tenant-context.ts
  </files>
  <action>
Create `src/lib/db/tenant-context.ts` to manage tenant context across async operations:

```typescript
import { AsyncLocalStorage } from 'async_hooks';

// Tenant context stored in AsyncLocalStorage for request-scoped isolation
const tenantStorage = new AsyncLocalStorage<string>();

/**
 * Execute a function with a specific tenant context.
 * All database operations within the function will be scoped to this tenant.
 */
export function withTenantContext<T>(tenantId: string, fn: () => T): T {
  return tenantStorage.run(tenantId, fn);
}

/**
 * Get the current tenant ID from context.
 * Returns undefined if not within a tenant context.
 */
export function getTenantContext(): string | undefined {
  return tenantStorage.getStore();
}

/**
 * Require tenant context - throws if not set.
 * Use this when tenant context is mandatory.
 */
export function requireTenantContext(): string {
  const tenantId = getTenantContext();
  if (!tenantId) {
    throw new Error('Tenant context is required but not set');
  }
  return tenantId;
}
```
  </action>
  <verify>
- File exists at `src/lib/db/tenant-context.ts`
- TypeScript compiles without errors: `npx tsc --noEmit`
  </verify>
  <done>Tenant context utilities created with AsyncLocalStorage</done>
</task>

<task type="auto">
  <name>Task 2: Create tenant-aware Prisma client</name>
  <files>
    src/lib/db/prisma.ts
  </files>
  <action>
Create `src/lib/db/prisma.ts` with a Prisma client that automatically injects tenant filtering:

```typescript
import { PrismaClient } from '@prisma/client';
import { getTenantContext } from './tenant-context';

// Singleton pattern for Prisma client in development
const globalForPrisma = globalThis as unknown as {
  prisma: ReturnType<typeof createPrismaClient> | undefined;
};

function createPrismaClient() {
  const baseClient = new PrismaClient({
    log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
  });

  // Extend client with tenant isolation
  return baseClient.$extends({
    query: {
      // Tenant-scoped models that require filtering
      wedding: {
        async findMany({ args, query }) {
          const tenantId = getTenantContext();
          if (tenantId) {
            args.where = { ...args.where, tenantId };
          }
          return query(args);
        },
        async findFirst({ args, query }) {
          const tenantId = getTenantContext();
          if (tenantId) {
            args.where = { ...args.where, tenantId };
          }
          return query(args);
        },
        async findUnique({ args, query }) {
          // For findUnique, we validate tenant after fetch
          const result = await query(args);
          const tenantId = getTenantContext();
          if (result && tenantId && result.tenantId !== tenantId) {
            return null; // Don't expose cross-tenant data
          }
          return result;
        },
        async create({ args, query }) {
          const tenantId = getTenantContext();
          if (tenantId && !args.data.tenantId) {
            args.data = { ...args.data, tenantId };
          }
          return query(args);
        },
        async update({ args, query }) {
          const tenantId = getTenantContext();
          if (tenantId) {
            args.where = { ...args.where, tenantId };
          }
          return query(args);
        },
        async delete({ args, query }) {
          const tenantId = getTenantContext();
          if (tenantId) {
            args.where = { ...args.where, tenantId };
          }
          return query(args);
        },
      },
      guest: {
        async findMany({ args, query }) {
          const tenantId = getTenantContext();
          if (tenantId) {
            args.where = {
              ...args.where,
              wedding: { tenantId },
            };
          }
          return query(args);
        },
        async create({ args, query }) {
          // Guest creation should verify wedding belongs to tenant
          // This is handled by the wedding foreign key constraint
          return query(args);
        },
      },
      event: {
        async findMany({ args, query }) {
          const tenantId = getTenantContext();
          if (tenantId) {
            args.where = {
              ...args.where,
              wedding: { tenantId },
            };
          }
          return query(args);
        },
        async create({ args, query }) {
          // Event creation should verify wedding belongs to tenant
          return query(args);
        },
      },
    },
  });
}

export const prisma = globalForPrisma.prisma ?? createPrismaClient();

if (process.env.NODE_ENV !== 'production') {
  globalForPrisma.prisma = prisma;
}

// Re-export tenant context for convenience
export { withTenantContext, getTenantContext, requireTenantContext } from './tenant-context';
```
  </action>
  <verify>
- File exists at `src/lib/db/prisma.ts`
- TypeScript compiles without errors: `npx tsc --noEmit`
- Imports work correctly
  </verify>
  <done>Prisma client extended with automatic tenant filtering on Wedding, Guest, Event models</done>
</task>

<task type="auto">
  <name>Task 3: Update tenant page to use Prisma with context</name>
  <files>
    src/app/[domain]/page.tsx
  </files>
  <action>
Update `src/app/[domain]/page.tsx` to look up tenant from database:

```typescript
import { prisma, withTenantContext } from '@/lib/db/prisma';
import { notFound } from 'next/navigation';

interface PageProps {
  params: Promise<{ domain: string }>;
}

export default async function TenantHomePage({ params }: PageProps) {
  const { domain } = await params;

  // Look up tenant by subdomain (no tenant context needed for this lookup)
  const tenant = await prisma.tenant.findUnique({
    where: { subdomain: domain },
    include: {
      wedding: true,
    },
  });

  if (!tenant) {
    notFound();
  }

  // If tenant exists but no wedding configured yet
  if (!tenant.wedding) {
    return (
      <main className="min-h-screen flex flex-col items-center justify-center p-4">
        <h1 className="text-2xl font-bold md:text-4xl mb-4">
          {tenant.name}
        </h1>
        <p className="text-gray-600">
          This wedding site is being set up. Check back soon!
        </p>
      </main>
    );
  }

  // Use tenant context for any further tenant-scoped operations
  return withTenantContext(tenant.id, () => (
    <main className="min-h-screen flex flex-col items-center justify-center p-4">
      <h1 className="text-2xl font-bold md:text-4xl mb-4">
        {tenant.wedding!.partner1Name} & {tenant.wedding!.partner2Name}
      </h1>
      {tenant.wedding!.weddingDate && (
        <p className="text-xl text-gray-600">
          {new Date(tenant.wedding!.weddingDate).toLocaleDateString('en-US', {
            weekday: 'long',
            year: 'numeric',
            month: 'long',
            day: 'numeric',
          })}
        </p>
      )}
      <p className="text-sm text-gray-400 mt-8">
        (Full wedding site will be built in Phase 3)
      </p>
    </main>
  ));
}
```

Note: This page will show a 404 until we have a database with seed data. That's expected - the structure is correct.
  </action>
  <verify>
- File compiles: `npx tsc --noEmit`
- Page uses prisma import from @/lib/db/prisma
- withTenantContext is used for tenant-scoped rendering
  </verify>
  <done>Tenant page performs database lookup and uses tenant context</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npx tsc --noEmit` passes - all TypeScript valid
2. `src/lib/db/tenant-context.ts` exports withTenantContext, getTenantContext, requireTenantContext
3. `src/lib/db/prisma.ts` exports tenant-aware prisma client
4. `src/app/[domain]/page.tsx` uses prisma and withTenantContext

Note: Full database integration test requires DATABASE_URL. The code structure and types are verified at this stage.
</verification>

<success_criteria>
- AsyncLocalStorage tenant context propagates across async boundaries
- Prisma client extension automatically filters Wedding/Guest/Event by tenant
- Tenant page demonstrates the lookup pattern (will work once database is connected)
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
