---
phase: 08-guest-messaging
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - prisma/schema.prisma
  - src/components/emails/BroadcastEmail.tsx
  - src/app/(platform)/dashboard/messaging/actions.ts
autonomous: true

must_haves:
  truths:
    - "BroadcastMessage model stores message content, status, and Resend email IDs"
    - "Broadcast email template renders personalized greeting with HTML content"
    - "Server actions can send immediate broadcasts via batch API"
    - "Server actions can schedule broadcasts with individual sends (batch doesn't support scheduledAt)"
    - "Server actions can cancel pending scheduled messages"
  artifacts:
    - path: "prisma/schema.prisma"
      provides: "BroadcastMessage model with MessageStatus enum"
      contains: "model BroadcastMessage"
    - path: "src/components/emails/BroadcastEmail.tsx"
      provides: "React email template for broadcasts"
      exports: ["BroadcastEmail"]
    - path: "src/app/(platform)/dashboard/messaging/actions.ts"
      provides: "Server actions for send, schedule, cancel"
      exports: ["sendBroadcast", "scheduleBroadcast", "cancelBroadcast", "getBroadcastMessages"]
  key_links:
    - from: "src/app/(platform)/dashboard/messaging/actions.ts"
      to: "src/lib/email/resend.ts"
      via: "resend client import"
      pattern: "import.*resend.*from.*@/lib/email/resend"
    - from: "src/app/(platform)/dashboard/messaging/actions.ts"
      to: "prisma.broadcastMessage"
      via: "database persistence"
      pattern: "prisma\\.broadcastMessage\\.(create|update|findMany)"
---

<objective>
Implement the Guest Messaging data layer and server actions for Phase 8.

Purpose: Enable couples to send broadcast emails to all guests, either immediately or scheduled for future delivery. This plan establishes the database schema, email template, and server actions that the UI will consume.

Output: BroadcastMessage model, BroadcastEmail template, and server actions for send/schedule/cancel operations.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@wedding-platform/.planning/PROJECT.md
@wedding-platform/.planning/ROADMAP.md
@wedding-platform/.planning/STATE.md
@wedding-platform/.planning/phases/08-guest-messaging/08-RESEARCH.md

# Existing patterns to follow
@wedding-platform/prisma/schema.prisma
@wedding-platform/src/lib/email/resend.ts
@wedding-platform/src/components/emails/RsvpReminderEmail.tsx
@wedding-platform/src/app/(platform)/dashboard/rsvp/actions.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add BroadcastMessage schema and run db push</name>
  <files>prisma/schema.prisma</files>
  <action>
Add the MessageStatus enum and BroadcastMessage model to the schema:

```prisma
// Add after PhotoStatus enum
enum MessageStatus {
  PENDING    // Scheduled but not yet sent
  SENT       // Successfully delivered to Resend
  CANCELLED  // Cancelled before sending
  FAILED     // Failed to send
}

// Add after GuestPhoto model
model BroadcastMessage {
  id           String        @id @default(cuid())
  weddingId    String
  wedding      Wedding       @relation(fields: [weddingId], references: [id], onDelete: Cascade)

  subject      String
  content      String        @db.Text     // HTML content from textarea

  // Scheduling
  scheduledFor DateTime?                  // null = sent immediately
  sentAt       DateTime?                  // When actually sent/delivered to Resend
  status       MessageStatus @default(PENDING)

  // Resend tracking - store email IDs for cancellation
  resendEmailIds String[]                 // Array of Resend email IDs
  recipientCount Int

  createdAt    DateTime      @default(now())
  updatedAt    DateTime      @updatedAt

  @@index([weddingId])
  @@index([weddingId, status])
}
```

Add `broadcastMessages BroadcastMessage[]` relation to the Wedding model.

Run `npx prisma db push` and `npx prisma generate` from the wedding-platform directory.
  </action>
  <verify>
Run `npx prisma db push` completes without errors. Run `npx prisma generate` completes. TypeScript can import BroadcastMessage type from @prisma/client.
  </verify>
  <done>MessageStatus enum and BroadcastMessage model exist in schema. Prisma client generated with new types.</done>
</task>

<task type="auto">
  <name>Task 2: Create BroadcastEmail template and server actions</name>
  <files>
    src/components/emails/BroadcastEmail.tsx
    src/app/(platform)/dashboard/messaging/actions.ts
  </files>
  <action>
**Create BroadcastEmail.tsx** following RsvpReminderEmail.tsx pattern:

```typescript
// src/components/emails/BroadcastEmail.tsx
import {
  Html, Head, Body, Container, Section,
  Heading, Text, Button, Preview, Hr,
} from "@react-email/components";

export interface BroadcastEmailProps {
  guestName: string;
  coupleNames: string;
  subject: string;
  content: string;      // Plain text content (not HTML for simplicity)
  ctaText?: string;
  ctaUrl?: string;
}

export function BroadcastEmail({ guestName, coupleNames, subject, content, ctaText, ctaUrl }: BroadcastEmailProps) {
  // Render with proper styling, personalized greeting, content, optional CTA button
  // Follow same styling as RsvpReminderEmail
}
```

**Create messaging/actions.ts** with server actions:

1. `getBroadcastMessages(tenantId: string)` - List all messages for wedding, ordered by createdAt desc
2. `getBroadcastMessage(id: string)` - Get single message details
3. `sendBroadcast(formData: FormData)` - Send immediate broadcast:
   - Validate subject (required, max 200 chars) and content (required)
   - Get guests with email addresses
   - Use `resend.batch.send()` for up to 100 emails per call
   - Create BroadcastMessage record with status SENT
4. `scheduleBroadcast(formData: FormData)` - Schedule for future:
   - Validate scheduledFor is within 30 days
   - Use individual `resend.emails.send()` with scheduledAt (batch doesn't support it)
   - Add 500ms delay between sends to avoid rate limiting
   - Store all resendEmailIds for cancellation
   - Create BroadcastMessage with status PENDING
5. `cancelBroadcast(messageId: string)` - Cancel scheduled:
   - Only allow if status is PENDING
   - Call `resend.emails.cancel(id)` for each stored email ID
   - Update status to CANCELLED

Key patterns from research:
- Batch API does NOT support scheduledAt - must use individual sends
- Rate limit: 2 req/sec, add 500ms delays between individual sends
- Store resendEmailIds[] array for cancellation capability
- Validate scheduledFor is within 30 days (Resend limit)
- Filter guests with `where: { email: { not: null } }`

Use `withTenantContext` for all queries. Follow existing actions.ts patterns in dashboard folders.
  </action>
  <verify>
TypeScript compiles without errors. Imports resolve correctly. Server actions export the required functions.
  </verify>
  <done>BroadcastEmail template exists. Server actions for send, schedule, cancel, and list operations exist.</done>
</task>

</tasks>

<verification>
1. `npx prisma db push` succeeds
2. `npx prisma generate` succeeds
3. `npm run build` compiles without TypeScript errors
4. Schema includes MessageStatus enum and BroadcastMessage model
5. BroadcastEmail.tsx exports BroadcastEmail component
6. actions.ts exports sendBroadcast, scheduleBroadcast, cancelBroadcast, getBroadcastMessages
</verification>

<success_criteria>
- BroadcastMessage model persists messages with status tracking
- Email template renders personalized broadcasts
- Server actions handle immediate sends, scheduled sends, and cancellation
- All code follows existing project patterns (tenant isolation, server actions)
</success_criteria>

<output>
After completion, create `.planning/phases/08-guest-messaging/08-01-SUMMARY.md`
</output>
